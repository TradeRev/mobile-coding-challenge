//
//  LoginInteractor.swift
//  ImageViewer
//
//  Created by Zakhar Sukhanov on 2017-12-08.
//  Copyright (c) 2017 Zakhar Sukhanov. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import WebKit
import Alamofire
import PromiseKit
import SwiftyJSON

protocol LoginBusinessLogic
{
  func doAuthenticate(request: Login.AuthenticateRequest)
}

protocol LoginDataStore
{

}

class LoginInteractor: NSObject, LoginBusinessLogic, LoginDataStore
{
  var presenter: LoginPresentationLogic?
  
  // MARK: Do something
  
  func doAuthenticate(request: Login.AuthenticateRequest)
  {
    guard let authorizationURL = self.authorizationURL() else {
      presenter?.presentError(error: Login.LoginError(err: IVError(desc: "Failed to construct Authorization URL")))
      return
    }
    
    request.clientArea.navigationDelegate = self
    request.clientArea.load(authorizationURL)
  }

  
  fileprivate func authorizationURL() -> URLRequest? {
    guard let authUrl = URL(string: Settings.shared.authorizationURL) else {
      Log.error("WRONG APPLICATION URL \(Settings.shared.authorizationURL)")
      return nil
    }
    
    return URLRequest(url: NSURL(string: "\(authUrl)?client_id=\(Settings.shared.applicationID)&redirect_uri=\(Settings.shared.redirectURL)&response_type=code&scope=public")! as URL)
  }
  
  
  fileprivate func accessTokenURL(code: String) -> URLRequest? {
    guard let tokenUrl = URL(string: Settings.shared.tokenURL) else {
      Log.error("WRONG APPLICATION URL \(Settings.shared.tokenURL)")
      return nil
    }
    
    return URLRequest(url: NSURL(string: "\(tokenUrl)?grant_type=authorization_code&client_id=\(Settings.shared.applicationID)&client_secret=\(Settings.shared.secret)&redirect_uri=\(Settings.shared.redirectURL)&code=\(code)")! as URL)
  }
  
  
  fileprivate func requestToken(url: URL) -> Promise<String> {
    return Promise { fulfill, reject in
      guard let code = extractCode(redirectURL: url) else {
        Log.error("ERROR: Can't extract code from redirect URL \(url)")
        return reject(IVError(desc: "ERROR: Can't extract code from redirect URL \(url)"))
      }
      
      guard let accessTokenURL = accessTokenURL(code: code)?.url?.absoluteString else {
        Log.error("ERROR: UNABLE TO CREATE ACCESS TOKEN URL")
        return reject(IVError(desc: "ERROR: UNABLE TO CREATE ACCESS TOKEN URL"))
      }
      
      Alamofire.request(accessTokenURL, method: .post, parameters: [:],encoding: JSONEncoding.default, headers: nil).responseJSON {
        response in
        switch response.result {
        case .success(_):
          if let jsonData = response.data {
            let json = JSON(data: jsonData)
            fulfill(json["access_token"].stringValue)
          } else {
            reject(IVError(desc: "FAILED TO PARSE RESPONSE"))
          }
        case .failure(let error):
          reject(error)
        }
      }
    }
  }
  
  
  fileprivate func extractCode(redirectURL: URL) -> String? {
    let items = redirectURL.queryItems
    return items["code"]
  }
}


extension LoginInteractor : WKNavigationDelegate, WKUIDelegate {

  public func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Swift.Void)
  {
    if let requestURL = navigationAction.request.url
    {
      // TODO: process case when deny pressed
      if self.checkIfRedirectUrl(url: requestURL) {
        self.requestToken(url: requestURL).then(execute: { [unowned self] (token) -> Void in
          Log.info("TOKEN: \(token)")
          Settings.shared.token = token
          self.presenter?.presentPhotGrid()
        }).catch(execute: { [unowned self] (err) in
          Log.error("FAILED GETTING A TOKEN: \(err)")
          self.presenter?.presentError(error: Login.LoginError(err: IVError(desc: err.localizedDescription)))
        })
        return decisionHandler(.cancel)
      }
    }
    decisionHandler(.allow)
  }

  
  fileprivate func checkIfRedirectUrl(url: URL) -> Bool {
    guard let redirectURL = URL(string: Settings.shared.redirectURL) else {
      Log.error("ERROR: \(Settings.shared.redirectURL)")
      return false
    }
    
    if (url.scheme == redirectURL.scheme && url.host == redirectURL.host && url.path == redirectURL.path) {
      return true
    }
    return false
  }
}
